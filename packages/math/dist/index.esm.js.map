{"version":3,"file":"index.esm.js","sources":["../index.js"],"sourcesContent":["/**\n * @module math\n * @description Collection of math functions\n */\n\n/**\n * Linear interpolation between a two values\n * @param  {Number} min      Minimum possible value\n * @param  {Number} max      Maximum possible value\n * @param  {Number} fraction Current position\n * @return {Number}          The interpolated value\n *\n * @example\n * import {lerp} from '@okiba/math'\n * const xPosition = lerp(0, 100, 0.5)\n * console.log(xPosition) // 50\n */\nexport function lerp(min, max, fraction) {\n  return (max - min) * fraction + min\n}\n\n/**\n * Maps a value between two ranges\n * @param  {Number} n       Value to map\n * @param  {Number} min1    Source range minimum\n * @param  {Number} max1    Source range maximum\n * @param  {Number} min2    Target range minimum\n * @param  {Number} max2    Target range maximum\n * @return {Number}         Mapped value\n *\n * @example\n * import {map} from '@okiba/math'\n *\n * const x = map(0.5, 0, 1, 0, 1000)\n * console.log(x) // 500\n *\n * const y = map(0, -1, 1, -1000, 1000)\n * console.log(y) // 0\n */\nexport function map(n, min1, max1, min2, max2) {\n  return (n - min1) * (max2 - min2) / (max1 - min1) + min2\n}\n\n\n/**\n * Limit a value between a min and a max (inclusive)\n * @param  {Number} n   Value to cap\n * @param  {Number} min Minimum possible value\n * @param  {Number} max Maximum possible value\n * @return {Number}     Capped value\n *\n * @example\n * import {cap} from '@okiba/math'\n * let progress = 1.1\n * progress = cap(0, 1, progress)\n * console.log(progress) // 1\n */\nexport function cap(n, min, max) {\n  return Math.min(Math.max(n, min), max)\n}\n\n/**\n * Distance between two numbers\n * @param  {Number} x1 First number\n * @param  {Number} x2 Second number\n * @return {Number}    Distance between the values\n *\n * @example\n * import {distance} from '@okiba/math'\n * const x1 = -100, x2 = 100\n * const d = distance(x1, x2)\n * console.log(d) // 200\n */\nexport function distance(x1, x2) {\n  return Math.abs(x1 - x2)\n}\n\n\nconst roundMap = {}\n/**\n * Round a number with given precision, with memoized powers\n * @param  {Number} n Number to round\n * @param  {Number} [p=3] Precision of digits to leave\n * @return {Number} Rounded number\n *\n * @example\n * import {round} from '@okiba/math'\n * const rounded = distance(1.111111, 3)\n * console.log(rounded) // 1.111\n */\nexport function round(n, p = 3) {\n  if (!roundMap[p]) {\n    roundMap[p] = Math.pow(10, p)\n  }\n  return Math.round(n * roundMap[p]) / roundMap[p]\n}\n"],"names":["lerp","min","max","fraction","map","n","min1","max1","min2","max2","cap","Math","distance","x1","x2","abs","roundMap","round","p","pow"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA,AAAO,SAASA,IAAT,CAAcC,GAAd,EAAmBC,GAAnB,EAAwBC,QAAxB,EAAkC;SAChC,CAACD,GAAG,GAAGD,GAAP,IAAcE,QAAd,GAAyBF,GAAhC;;;;;;;;;;;;;;;;;;;;;AAqBF,AAAO,SAASG,GAAT,CAAaC,CAAb,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,IAAlC,EAAwC;SACtC,CAACJ,CAAC,GAAGC,IAAL,KAAcG,IAAI,GAAGD,IAArB,KAA8BD,IAAI,GAAGD,IAArC,IAA6CE,IAApD;;;;;;;;;;;;;;;;AAiBF,AAAO,SAASE,GAAT,CAAaL,CAAb,EAAgBJ,GAAhB,EAAqBC,GAArB,EAA0B;SACxBS,IAAI,CAACV,GAAL,CAASU,IAAI,CAACT,GAAL,CAASG,CAAT,EAAYJ,GAAZ,CAAT,EAA2BC,GAA3B,CAAP;;;;;;;;;;;;;;;AAeF,AAAO,SAASU,QAAT,CAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;SACxBH,IAAI,CAACI,GAAL,CAASF,EAAE,GAAGC,EAAd,CAAP;;AAIF,IAAME,QAAQ,GAAG,EAAjB;;;;;;;;;;;;;AAYA,AAAO,SAASC,KAAT,CAAeZ,CAAf,EAAyB;MAAPa,CAAO,uEAAH,CAAG;;MAC1B,CAACF,QAAQ,CAACE,CAAD,CAAb,EAAkB;IAChBF,QAAQ,CAACE,CAAD,CAAR,GAAcP,IAAI,CAACQ,GAAL,CAAS,EAAT,EAAaD,CAAb,CAAd;;;SAEKP,IAAI,CAACM,KAAL,CAAWZ,CAAC,GAAGW,QAAQ,CAACE,CAAD,CAAvB,IAA8BF,QAAQ,CAACE,CAAD,CAA7C;;;;;"}